#ifndef PATH_H
#define PATH_H

#include <iostream>
#include <cstring>
#include <vector>

#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/MarkerArray.h>

#include "node3d.h"
#include "constants.h"
#include "helper.h"
namespace HybridAStar {
/*!
   \brief A class for tracing and visualizing the path generated by the Planner
*/
class Path {
 public:
  /// The default constructor initializing the path object and setting publishers for the same.
  Path(bool smoothed = false) {
    std::string pathTopic = "/path";
    std::string pathNodesTopic = "/pathNodes";
    std::string pathVehicleTopic = "/pathVehicle";

    if (smoothed) {
      pathTopic = "/sPath";
      pathNodesTopic = "/sPathNodes";
      pathVehicleTopic = "/sPathVehicle";
      this->smoothed = smoothed;
    }

    // _________________
    // TOPICS TO PUBLISH
    pubPath = n.advertise<nav_msgs::Path>(pathTopic, 1);
    pubPathNodes = n.advertise<visualization_msgs::MarkerArray>(pathNodesTopic, 1);
    pubPathVehicles = n.advertise<visualization_msgs::MarkerArray>(pathVehicleTopic, 1);
    pubvehicletext  = n.advertise<visualization_msgs::MarkerArray>("/vehicle_text",1);
    // CONFIGURE THE CONTAINER
    pubpayload = n.advertise<visualization_msgs::MarkerArray>("/payload_marker",1);
    publeaderuav = n.advertise<visualization_msgs::MarkerArray>("/leader_uav",1);
    pubfolloweruav = n.advertise<visualization_msgs::MarkerArray>("follower_uav",1);

    publeaderuav_text = n.advertise<visualization_msgs::MarkerArray>("leader_uav_text",1);
    pubfolloweruav_text = n.advertise<visualization_msgs::MarkerArray>("follower_uav_text",1);
    pubPathdot = n.advertise<visualization_msgs::MarkerArray>("path_dot",1);
    path.header.frame_id = "path";
  }

  //  // __________
  //  // TRACE PATH
  //  /*!
  //     \brief Given a node pointer the path to the root node will be traced recursively
  //     \param node a 3D node, usually the goal node
  //     \param i a parameter for counting the number of nodes
  //  */
  //  void tracePath(const Node3D* node, int i = 0);
  /*!
     \brief Given a node pointer the path to the root node will be traced recursively
     \param node a 3D node, usually the goal node
     \param i a parameter for counting the number of nodes
  */
  void updatePath(std::vector<Node3D> nodePath);
  /*!
     \brief Adds a segment to the path
     \param node a 3D node
  */
  void addSegment(const Node3D& node);
  /*!
     \brief Adds a node to the path
     \param node a 3D node
     \param i a parameter for counting the number of nodes
  */
  void addNode(const Node3D& node, int i);
  /*!
     \brief Adds a vehicle shape to the path
     \param node a 3D node
     \param i a parameter for counting the number of nodes
  */
  void addVehicle(const Node3D& node, int i);
  void payload(double x , double y, int i);
  void vehicle_text(double x , double y, int i);
  void leader_uav(double x , double y, int i);
  void follower_uav(double x , double y , int i);
  void plotdot(double x , double y , int i);
  // ______________
  // PUBLISH METHODS

  /// Clears the path
  void clear();
  /// Publishes the path
  void publishPath() { pubPath.publish(path); }
  /// Publishes the nodes of the path
  void publishPathNodes() {// pubPathNodes.publish(pathNodes);
//                            pathNodes.markers.pop_back();
                            //pathNodes.markers.erase(pathNodes.markers.begin());


                          }
  /// Publishes the vehicle along the path
  void publishPathVehicles() {
                                pubPathVehicles.publish(pathVehicles);
                                pubvehicletext.publish(pathVehicletexts);
                                pubpayload.publish(pathpayloads);
                                publeaderuav.publish(pathleaderuav);
                                pubfolloweruav.publish(pathfolloweruav);
                                publeaderuav_text.publish(pathleaderuav_text);
                                pubfolloweruav_text.publish(pathfolloweruav_text);


                                //pubPathdot.publish(pathdots);

                             }



 private:
  /// A handle to the ROS node
  ros::NodeHandle n;
  /// Publisher for the path as a spline
  ros::Publisher pubPath;
  /// Publisher for the nodes on the path
  ros::Publisher pubPathNodes;
  /// Publisher for the vehicle along the path
  ros::Publisher pubPathVehicles;
  /// Path data structure for visualization
  ///
  ros::Publisher publeaderuav;
  ros::Publisher pubfolloweruav;
  ros::Publisher pubpayload;
  ros::Publisher pubvehicletext;
  ros::Publisher publeaderuav_text;
  ros::Publisher pubfolloweruav_text;
  ros::Publisher pubPathdot;
  ///
  /// \brief path
  ///

  nav_msgs::Path path;
  /// Nodes data structure for visualization
  visualization_msgs::MarkerArray pathNodes;
  /// Vehicle data structure for visualization
  visualization_msgs::MarkerArray pathVehicles;
  visualization_msgs::MarkerArray pathVehicletexts;
  visualization_msgs::MarkerArray pathpayloads;
  visualization_msgs::MarkerArray pathdots;
  visualization_msgs::MarkerArray pathleaderuav;
  visualization_msgs::MarkerArray pathfolloweruav;

  visualization_msgs::MarkerArray pathleaderuav_text;
  visualization_msgs::MarkerArray pathfolloweruav_text;

    geometry_msgs::Point start_point;
    geometry_msgs::Point end_point;

   geometry_msgs::Quaternion  orientaiotn;
  /// Value that indicates that the path is smoothed/post processed
  bool smoothed = false;
};
}
#endif // PATH_H
